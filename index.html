<style>
  /* добавил рамку для наглядности */
  canvas {
    border: 2px solid red;
    transition: transform 0.3s ease-out;
  }
</style>

<script type="module">
  // Firebase SDK
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, get, set, onValue, remove } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAGB8czq8dPpHRhoToaVImZgcHrVuimEmE",
    authDomain: "wheel-of-tasks.firebaseapp.com",
    databaseURL: "https://wheel-of-tasks-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "wheel-of-tasks",
    storageBucket: "wheel-of-tasks.appspot.com", // исправлено
    messagingSenderId: "1022732084945",
    appId: "1:102273208494cc7f0"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const usedRef = ref(db, "usedTasks");

  const tasks = {
    1: "Ущипни кого-то из присутствующих.",
    2: "Подсунь записку с фальшивым признанием в любви кому-то из учеников, подписавшись именем профессора.",
    3: "Предложи кому-нибудь ударить тебя по пятой точке.",
    4: "Запиши провокационную сплетню о себе и запусти ее самолетиком так, чтоб она попала на стол профессора.",
    5: "Придумай как оказаться за спиной профессора и покривляйся, затем как ни в чем не бывало вернись на место.",
    6: "Поднять руку и разговаривать с профессором исключительно при помощи рифмоплетных стихосложений.",
    7: "Вставь слово «поцелуй» или «соблазн» в собственный ответ на вопрос профессора, сохрани серьезное лицо и жди реакции.",
    8: "Прочти абзац из учебника так, будто сгораешь от желания.",
    9: "Поменяйся с кем-то своими носками (не забудь их надеть).",
    10: "Сделай профессору комплимент с налётом флирта.",
    11: "Расхваливай себя, как лучшую вторую половинку, которую необходимо иметь всем (как в рекламе).",
    12: "Внезапно бурно поддержи профессора и толкни речь, словно на выпускном."
  };

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const spinBtn = document.getElementById("spin");
  const resetBtn = document.getElementById("reset");
  const resultBox = document.getElementById("result");
  const colors = ["#f8b195", "#f67280", "#c06c84", "#6c5b7b", "#355c7d", "#99b898"];
  let segments = [];
  let rotation = 0;
  let spinning = false;

  function drawWheel() {
    console.log("drawWheel called, segments:", segments);
    ctx.clearRect(0, 0, 300, 300);

    if (segments.length === 0) {
      // Если заданий нет — рисуем серый круг с надписью
      ctx.beginPath();
      ctx.arc(150, 150, 150, 0, 2 * Math.PI);
      ctx.fillStyle = "#ccc";
      ctx.fill();
      ctx.fillStyle = "#333";
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Все задания выполнены", 150, 150);

      // Дополнительно — рисуем тестовый голубой круг для проверки
      ctx.fillStyle = "lightblue";
      ctx.beginPath();
      ctx.arc(150, 150, 140, 0, Math.PI * 2);
      ctx.fill();

      return;
    }

    const anglePerSegment = (2 * Math.PI) / segments.length;
    for (let i = 0; i < segments.length; i++) {
      const startAngle = i * anglePerSegment;
      const endAngle = startAngle + anglePerSegment;
      ctx.beginPath();
      ctx.moveTo(150, 150);
      ctx.arc(150, 150, 150, startAngle, endAngle);
      ctx.fillStyle = colors[i % colors.length];
      ctx.fill();

      ctx.save();
      ctx.translate(150, 150);
      ctx.rotate(startAngle + anglePerSegment / 2);

      ctx.fillStyle = "#fff";
      ctx.font = "14px Arial";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";

      let text = tasks[segments[i]];
      if (text.length > 30) text = text.slice(0, 27) + "...";
      ctx.fillText(text, 140, 0);

      ctx.restore();
    }
  }

  function updateSegments(used) {
    segments = Object.keys(tasks).map(Number).filter(n => !used.includes(n));
    console.log("updateSegments called. Used tasks:", used, "Segments to draw:", segments);
    drawWheel();
  }

  onValue(usedRef, (snapshot) => {
    const used = snapshot.val() || [];
    console.log("Firebase used tasks:", used);
    updateSegments(used);
  });

  spinBtn.addEventListener("click", async () => {
    const snapshot = await get(usedRef);
    const used = snapshot.val() || [];
    segments = Object.keys(tasks).map(Number).filter(n => !used.includes(n));
    if (spinning || segments.length === 0) return;

    spinning = true;
    resultBox.textContent = "";
    const spinTime = 4000;
    const extraDegrees = 360 * 5;
    const randomSegmentIndex = Math.floor(Math.random() * segments.length);
    const degreesPerSegment = 360 / segments.length;
    const stopAngle = (segments.length - randomSegmentIndex) * degreesPerSegment - degreesPerSegment / 2;
    const finalAngle = rotation + extraDegrees + stopAngle;
    const start = performance.now();

    function animate(time) {
      const progress = Math.min((time - start) / spinTime, 1);
      const easeOut = 1 - Math.pow(1 - progress, 3);
      rotation = finalAngle * easeOut;
      canvas.style.transform = `rotate(${rotation}deg)`;
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        spinning = false;
        const landedIndex = (segments.length - Math.floor((rotation % 360) / degreesPerSegment)) % segments.length;
        const taskNumber = segments[landedIndex];
        resultBox.textContent = `Задание: ${tasks[taskNumber]}`;
        used.push(taskNumber);
        set(usedRef, used);
      }
    }
    requestAnimationFrame(animate);
  });

  resetBtn.addEventListener("click", () => {
    remove(usedRef);
  });

  // Принудительный вызов отрисовки при загрузке
  drawWheel();
</script>
